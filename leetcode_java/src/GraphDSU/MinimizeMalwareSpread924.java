package GraphDSU;

import java.util.Arrays;

public class MinimizeMalwareSpread924 {
  public int minMalwareSpread(int[][] graph, int[] initial) {
    int N = graph.length;
    int[] colors = new int[N];// 存储每个节点的颜色
    Arrays.fill(colors, -1);
    int C = 0;
    for (int node = 0; node < N; node++) {
      if (colors[node] == -1) {
        // 为什么是C++ 因为一个节点的意味着新的联通分量产生 所以color会变化
        dfs(graph, colors, node, C++);
      }
    }
    // 每个颜色所包含的节点个数， 联通分量有多少个节点
    int[] size = new int[C];
    for (int color : colors) {
      size[color]++;
    }
    // 找到最终的 特殊节点 既 在联通分量中没有被
    int[] countColor = new int[C];
    for (int node : initial) {
      countColor[colors[node]]++;// 在initial中的节点的颜色的个数
    }
    int ans = Integer.MAX_VALUE;
    for (int node : initial) {
      if (countColor[colors[node]] == 1) {
        // 在initial中包含的颜色是只有一个
        if (ans == Integer.MAX_VALUE) {
          // 这个节点没有被访问过
          ans = node;
        } else if (size[colors[node]] > size[colors[ans]]) {
          //当前值所包含的联通分量值大于 另一个unique color的联通分量的值
          ans = node;
        } else if (size[colors[node]] == size[colors[ans]] && node < ans) {
          // 两个值不是联通的 但是都出现了一次 取节点值较小的那个
          ans = node;
        }
      }
    }
    if (ans == Integer.MAX_VALUE) {
      // 说明两个值是联通的 或者是不连通但是有多个联通分量的
      for (int node : initial) {
        ans = Math.min(ans, node);
      }
    }
    return ans;

  }

  public void dfs(int[][] graph, int[] colors, int node, int color) {
    colors[node] = color;
    for (int i = 0; i < graph.length; i++) {
      if (graph[node][i] == 1 && colors[i] == -1) {
        dfs(graph, colors, i, color);
      }
    }
  }

}
